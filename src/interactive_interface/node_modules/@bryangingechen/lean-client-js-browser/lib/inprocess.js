"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
}
Object.defineProperty(exports, "__esModule", { value: true });
// import * as BrowserFS from 'browserfs';
// avoid importing all BrowserFS backends per: https://github.com/jvilk/BrowserFS/issues/233#issuecomment-409523418
const ZipFS_1 = __importDefault(require("browserfs/dist/node/backend/ZipFS"));
const FS_1 = __importDefault(require("browserfs/dist/node/core/FS"));
const emscripten_fs_1 = __importDefault(require("browserfs/dist/node/generic/emscripten_fs"));
const lean_client_js_core_1 = require("lean-client-js-core");
class InProcessTransport {
    constructor(loadJs, libraryZip, memoryMB, loadOlean) {
        this.loadJs = loadJs;
        this.libraryZip = libraryZip;
        this.memoryMB = memoryMB;
        this.loadOlean = loadOlean;
    }
    connect() {
        if (self.Module) {
            throw new Error('cannot use more than one instance of InProcessTransport');
        }
        self.Module = {};
        Module.noExitRuntime = true;
        Module.preRun = [() => console.log('starting lean...')];
        const conn = new InProcessConnection();
        Module.print = (text) => {
            try {
                const msg = JSON.parse(text);
                // replace 'source' fields using olean_map.json if possible
                if (this.oleanMap && this.info) {
                    // info response
                    if (msg.record && msg.record.source && msg.record.source.file) {
                        msg.record.source.file = this.getUrl(msg.record.source.file);
                    }
                    else if (msg.results && !msg.file) {
                        for (let i = 0; i < msg.results.length; i++) {
                            if (msg.results[i].source && msg.results[i].source.file) {
                                msg.results[i].source.file = this.getUrl(msg.results[i].source.file);
                            }
                        }
                    }
                    else if (msg.completions) {
                        for (let i = 0; i < msg.completions.length; i++) {
                            if (msg.completions[i].source && msg.completions[i].source.file) {
                                msg.completions[i].source.file = this.getUrl(msg.completions[i].source.file);
                            }
                        }
                    }
                }
                conn.jsonMessage.fire(msg);
            }
            catch (e) {
                conn.error.fire({ error: 'connect', message: `cannot parse: ${text}, error: ${e}` });
            }
        };
        Module.printErr = (text) => conn.error.fire({ error: 'stderr', chunk: text });
        Module.TOTAL_MEMORY = this.memoryMB * 1024 * 1024;
        const emscriptenInitialized = new Promise((resolve, reject) => Module.onRuntimeInitialized = resolve);
        console.log('downloading lean...');
        conn.module = this.init(emscriptenInitialized);
        conn.module.catch((err) => conn.error.fire({
            error: 'connect',
            message: `could not start emscripten version of lean: ${err}`,
        }));
        return conn;
    }
    getUrl(sourceFile) {
        const file = sourceFile.slice(9, -5); // remove '/library/' prefix and '.lean'
        const url = this.info[this.oleanMap[file]];
        return url ? url + file + '.lean' : sourceFile;
    }
    init(emscriptenInitialized) {
        return __awaiter(this, void 0, void 0, function* () {
            const [loadJs, inited, library, oleanMap] = yield Promise.all([this.loadJs(), emscriptenInitialized, this.libraryZip, this.loadOlean()]);
            if (library) {
                const libraryFS = yield new Promise((resolve, reject) => ZipFS_1.default.Create({ zipData: library.zipBuffer }, (err, res) => err ? reject(err) : resolve(res)));
                const BrowserFS = new FS_1.default();
                BrowserFS.initialize(libraryFS);
                const BFS = new emscripten_fs_1.default(Module.FS, Module.PATH, Module.ERRNO_CODES, BrowserFS);
                Module.FS.createFolder(Module.FS.root, 'library', true, true);
                Module.FS.mount(BFS, { root: '/' }, '/library');
                this.info = library.urls;
            }
            this.oleanMap = oleanMap;
            (Module.lean_init || Module._lean_init)();
            console.log('lean server initialized.');
            return Module;
        });
    }
}
exports.InProcessTransport = InProcessTransport;
class InProcessConnection {
    constructor() {
        this.error = new lean_client_js_core_1.Event();
        this.jsonMessage = new lean_client_js_core_1.Event();
        this.alive = true;
    }
    send(jsonMsg) {
        this.module.then((mod) => {
            const msg = JSON.stringify(jsonMsg);
            const len = (lengthBytesUTF8 || mod.lengthBytesUTF8)(msg) + 1;
            const msgPtr = mod._malloc(len);
            (stringToUTF8 || mod.stringToUTF8)(msg, msgPtr, len);
            (mod.lean_process_request || mod._lean_process_request)(msgPtr);
            mod._free(msgPtr);
        });
    }
    dispose() { }
}
function loadJsOrWasm(urls, loadJs) {
    if (self.WebAssembly && urls.webassemblyJs && urls.webassemblyWasm) {
        // Module.wasmBinaryFile = urls.webassemblyWasm; // deprecated!
        Module.locateFile = () => urls.webassemblyWasm;
        return loadJs(urls.webassemblyJs);
    }
    else if (urls.javascript) {
        return loadJs(urls.javascript);
    }
    else {
        throw new Error(`cannot load lean.js from urls in ${urls}`);
    }
}
exports.loadJsOrWasm = loadJsOrWasm;
function loadInfoJson(infoUrl) {
    // if this fails let's continue (we just won't be able to resolve lean files to github)
    return new Promise((resolve, reject) => {
        const req = new XMLHttpRequest();
        req.responseType = 'text';
        req.open('GET', infoUrl);
        req.onloadend = (e) => {
            if (req.status === 200) {
                resolve(req.responseText);
            }
            else {
                console.log(`could not fetch ${infoUrl}: http code ${req.status} ${req.statusText}`);
                resolve(null);
            }
        };
        req.onerror = (e) => {
            console.log(`error fetching ${infoUrl}: ${e}`);
            resolve(null);
        };
        req.send();
    });
}
function loadBufferFromURL(url, metaUrl, needUrls) {
    return new Promise((resolve, reject) => {
        const req = new XMLHttpRequest();
        req.responseType = 'arraybuffer';
        req.open('GET', url);
        req.onloadend = (e) => {
            if (req.status === 200) {
                if (needUrls) {
                    loadInfoJson(metaUrl).then((info) => resolve({ zipBuffer: new Buffer(req.response), urls: JSON.parse(info) }));
                }
                else {
                    resolve({ zipBuffer: new Buffer(req.response) });
                }
            }
            else {
                reject(`could not fetch ${url}: http code ${req.status} ${req.statusText}`);
            }
        };
        req.onerror = (e) => reject(e);
        req.send();
    });
}
exports.loadBufferFromURL = loadBufferFromURL;
function loadBufferFromURLCached(url, metaUrl, libKey, dbName) {
    if (!url) {
        return null;
    }
    if (!url.toLowerCase().endsWith('.zip')) {
        return null;
    }
    if (!metaUrl) {
        metaUrl = url.slice(0, -3) + 'info.json';
    }
    if (!('indexedDB' in self)) {
        return loadBufferFromURL(url, metaUrl, true);
    }
    if (!libKey) {
        libKey = url.split('/').pop().slice(0, -4);
    }
    const infoPromise = loadInfoJson(metaUrl);
    if (!dbName) {
        dbName = 'leanlibrary';
    }
    const dbPromise = new Promise((resolve, reject) => {
        const ver = 3;
        const dbRequest = indexedDB.open(dbName, ver);
        dbRequest.onsuccess = (event) => {
            // console.log('opened indexedDB');
            resolve(dbRequest.result);
        };
        dbRequest.onerror = (event) => {
            console.log('failed to open indexedDB');
            reject(dbRequest.error);
        };
        dbRequest.onupgradeneeded = (event) => {
            const { result: db } = dbRequest;
            const arr = dbRequest.result.objectStoreNames;
            for (let j = 0; j < arr.length; j++) {
                db.deleteObjectStore(arr[j]);
            }
            // console.log('creating indexedDB');
            db.createObjectStore('library');
            db.createObjectStore('meta');
        };
    });
    const metaPromise = dbPromise.then((db) => new Promise((resolve, reject) => {
        const trans = db.transaction('meta').objectStore('meta').get(libKey);
        trans.onsuccess = (event) => {
            // console.log('retrieved info.json from cache', trans.result);
            resolve(trans.result);
        };
        trans.onerror = (event) => {
            console.log(`error getting info.json for ${libKey} from cache`);
            reject(trans.error);
        };
    }));
    return Promise.all([infoPromise, dbPromise, metaPromise])
        .then(([response, db, meta]) => {
        // TODO: better comparison between info.json and its cached version
        if (!meta || (meta !== response)) {
            // cache miss
            // console.log('cache miss!');
            return loadBufferFromURL(url, metaUrl).then((buff) => {
                return new Promise((res, rej) => {
                    // save buffer to cache
                    // console.log('saving library to cache');
                    const trans = db.transaction('library', 'readwrite').objectStore('library')
                        .put(buff.zipBuffer, libKey);
                    trans.onsuccess = (event) => {
                        // console.log('saved library to cache');
                        res({ zipBuffer: buff.zipBuffer, urls: JSON.parse(response) });
                    };
                    trans.onerror = (event) => {
                        console.log(`error saving ${libKey} to cache`, event);
                        rej(trans.error);
                    };
                });
                // write info.json to cache after library is cached
            }).then((buff) => new Promise((res, rej) => {
                // console.log('saving info.json to cache');
                const trans = db.transaction('meta', 'readwrite').objectStore('meta')
                    .put(response, libKey);
                trans.onsuccess = (event) => {
                    // console.log('saved info.json to cache');
                    // returns library buffer, not trans.result
                    res(buff);
                };
                trans.onerror = (event) => {
                    console.log(`error saving info.json for ${libKey} to cache`, event);
                    rej(trans.error);
                };
            }));
        }
        // cache hit: pretend that the meta and library stores are always in sync
        return new Promise((res, rej) => {
            // console.log('cache hit!');
            const trans = db.transaction('library').objectStore('library')
                .get(libKey);
            trans.onsuccess = (event) => {
                // console.log('retrieved library from cache', trans.result);
                res({ zipBuffer: new Buffer(trans.result), urls: JSON.parse(response) });
            };
            trans.onerror = (event) => {
                console.log(`error getting ${libKey} from cache`, event);
                rej(trans.error);
            };
        });
    }, (reason) => {
        console.log(`error in caching: ${reason}, falling back to uncached download`);
        return loadBufferFromURL(url, metaUrl, true);
    });
}
exports.loadBufferFromURLCached = loadBufferFromURLCached;
