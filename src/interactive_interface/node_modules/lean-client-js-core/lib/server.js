"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const event_1 = require("./event");
class Server {
    constructor(transport) {
        this.transport = transport;
        this.error = new event_1.Event();
        this.allMessages = new event_1.Event();
        this.tasks = new event_1.Event();
        this.logMessagesToConsole = false;
        this.currentSeqNum = 0;
        this.currentMessages = [];
        this.sentRequests = new Map();
    }
    connect() {
        this.conn = this.transport.connect();
        this.conn.jsonMessage.on((msg) => this.onMessage(msg));
        this.conn.error.on((msg) => this.error.fire(msg));
    }
    // TODO(gabriel): restore roi & files on restart?
    restart() {
        this.dispose();
        this.connect();
    }
    send(req) {
        if (!this.alive()) {
            return new Promise((resolve, reject) => reject('server is not alive'));
        }
        if (this.logMessagesToConsole) {
            console.log('=> server: ', req);
        }
        req.seq_num = this.currentSeqNum++;
        const promise = new Promise((resolve, reject) => this.sentRequests.set(req.seq_num, { resolve, reject }));
        this.conn.send(req);
        return promise;
    }
    info(file, line, column) {
        return this.send({ command: 'info', file_name: file, line, column });
    }
    sync(file, contents) {
        return this.send({ command: 'sync', file_name: file, content: contents });
    }
    complete(file, line, column, skipCompletions) {
        return this.send({ command: 'complete', file_name: file, line, column,
            skip_completions: skipCompletions || false });
    }
    search(query) {
        return this.send({ command: 'search', query });
    }
    allHoleCommands(file) {
        return this.send({ command: 'all_hole_commands', file_name: file });
    }
    holeCommands(file, line, column) {
        return this.send({ command: 'hole_commands', file_name: file, line, column });
    }
    hole(file, line, column, action) {
        return this.send({ command: 'hole', file_name: file, line, column, action });
    }
    roi(mode, files) {
        return this.send({ command: 'roi', files, mode });
    }
    alive() {
        return this.conn && this.conn.alive;
    }
    dispose() {
        if (this.conn) {
            this.conn.dispose();
            this.sentRequests.forEach((info, seqNum) => info.reject('disposed'));
            this.sentRequests.clear();
            this.currentSeqNum = 0;
            this.conn = null;
        }
    }
    onMessage(msg) {
        if (this.logMessagesToConsole) {
            console.log('<= server: ', msg);
        }
        const reqInfo = this.sentRequests.get(msg.seq_num); // undefined if msg.seq_num does not exist
        if (reqInfo !== undefined) {
            this.sentRequests.delete(msg.seq_num);
            if (msg.response === 'ok') {
                reqInfo.resolve(msg);
            }
            else {
                reqInfo.reject(msg.message || msg);
            }
        }
        else if (msg.response === 'all_messages') {
            const allMsgRes = msg;
            this.currentMessages = allMsgRes.msgs;
            this.allMessages.fire(allMsgRes);
        }
        else if (msg.response === 'additional_message') {
            const addMsgRes = msg;
            this.currentMessages = this.currentMessages.concat([addMsgRes.msg]);
            this.allMessages.fire({
                response: 'all_messages',
                msgs: this.currentMessages,
            });
        }
        else if (msg.response === 'current_tasks') {
            this.tasks.fire(msg);
        }
        else {
            // unrelated error
            this.error.fire({ error: 'unrelated', message: msg.message || JSON.stringify(msg) });
        }
    }
}
exports.Server = Server;
